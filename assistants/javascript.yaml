%YAML 1.1
---
name: JavaScript Assistant
version: 1.0.0
schema: v1

jan_provider: &jan_provider
  provider: openai
  apiKey: EMPTY
  apiBase: http://localhost:1337/v1

ollama_provider: &ollama_provider
  provider: ollama

models:
  - name: Cogito Big
    <<: *jan_provider
    model: cogito-v1:14b

  - name: Cogito Medium
    <<: *ollama_provider
    model: cogito:8b

  - name: Cogito Small
    <<: *ollama_provider
    model: cogito:3b

  - name: Qwen Coder
    <<: *jan_provider
    model: qwen2.5-coder-14b-instruct

  - name: Codestral
    <<: *jan_provider
    model: codestral:22b

  - name: Devstral
    <<: *ollama_provider
    model: devstral:latest

context:
  - provider: code
  - provider: codebase
  - provider: currentFile
  - provider: diff
  - provider: docs
  - provider: folder
  - provider: open
  - provider: problems
  - provider: search
  - provider: terminal

docs:
  - name: MDN JavaScript
    startUrl: https://developer.mozilla.org/en-US/docs/Web/JavaScript
    rootUrl: https://developer.mozilla.org/en-US/docs/Web/JavaScript

  - name: Vite
    startUrl: https://vite.dev/guide/
    rootUrl: https://vite.dev/guide/

  - name: React
    startUrl: https://react.dev/reference/
    rootUrl: https://react.dev/reference/
    faviconUrl: https://react.dev/favicon.ico

  - name: React Testing Library Docs
    startUrl: https://testing-library.com/docs/react-testing-library/intro/

  - name: Vue docs
    startUrl: https://vuejs.org/guide/
    rootUrl: https://vuejs.org/guide/

  - name: Pinia
    startUrl: https://pinia.vuejs.org/

  - name: GitHub
    startUrl: https://docs.github.com/en/

rules:
  - name: General Rules
    rule: |
      - I am an experienced engineer, so you can assume that I am knowledgeable about most programming topics and don't need to explain common concepts unless I ask.
      - Provide concise, technical responses by default.
      - If I ask you to elaborate, then provide more in-depth and explanatory responses.
      - Assume the latest version of programming languages and libraries unless otherwise specified or found in config files.
      - Follow the language's and/or framework's best practices, unless otherwise specified or found in the config files.

  - name: Functional and OOP
    rule: |
      - >-
        When generating, reviewing, or modifying code in mixed-paradigm languages, follow these guidelines:
        - Favor functional programming paradigms whenever possible, as long as the language supports it, for functions and their internals. Use OOP best practices for classes.
        - Use tail-recursion if the language supports tail call optimization.
        - Bundle functions into classes, following SOLID principles.
        - Favor constructs and techniques like Sets, map/reduce, and declarative over loops and imperative techniques when possible.
        - Favor inversion of control patterns whenever possible.

  - name: TDD
    rule: |
      - When generating, reviewing, or modifying code, always suggest tests to add or modify to prove the code's functionality.
      - Individual tests should be atomic.
      - All tests should be written in a way to avoid affecting other tests.
      - Tests should be written in the test dialect specified by the workspace's configuration files whenever possible. If no such file is available, default to the language or framework's most typical test suite unless otherwise specified.
      - Use the test suite's and language's features to avoid code duplication when possible.

  - name: SOLID Principles
    rule: |
      - >-
        When generating, reviewing, or modifying code, follow these guidelines to ensure adherence to SOLID principles:

        ## 1. Single Responsibility Principle (SRP)
        - Limit class scope to a single functional area or abstraction level.
        - When a class exceeds 100-150 lines, excluding boilerplate and markers (imports, brackets, blank lines, etc), consider if it has multiple responsibilities.
        - Separate cross-cutting concerns (logging, validation, error handling) from business logic.
        - Create dedicated classes for distinct operations like data access, business rules, and UI.
        - Method names should clearly indicate their singular purpose.
        - If a method description requires "and" or "or", it likely violates SRP.
        - Prioritize composition over inheritance when combining behaviors.

        ## 2. Open/Closed Principle (OCP)
        - Design classes to be extended without modification.
        - Use abstract classes and interfaces to define stable contracts.
        - Implement extension points for anticipated variations.
        - Favor strategy patterns over conditional logic.
        - Use configuration and dependency injection to support behavior changes.
        - Avoid switch/if-else chains based on type checking.
        - Provide hooks for customization in frameworks and libraries.
        - Design with polymorphism as the primary mechanism for extending functionality.

        ## 3. Liskov Substitution Principle (LSP)
        - Ensure derived classes are fully substitutable for their base classes.
        - Maintain all invariants of the base class in derived classes.
        - Never throw exceptions from methods that don't specify them in base classes.
        - Don't strengthen preconditions in subclasses.
        - Don't weaken postconditions in subclasses.
        - Never override methods with implementations that do nothing or throw exceptions.
        - Avoid type checking or downcasting, which may indicate LSP violations.
        - Prefer composition over inheritance when complete substitutability can't be achieved.

        ## 4. Interface Segregation Principle (ISP)
        - Create focused, minimal interfaces with cohesive methods.
        - Split large interfaces into smaller, more specific ones.
        - Design interfaces around client needs, not implementation convenience.
        - Avoid "fat" interfaces that force clients to depend on methods they don't use.
        - Use role interfaces that represent behaviors rather than object types.
        - Implement multiple small interfaces rather than a single general-purpose one.
        - Consider interface composition to build up complex behaviors.
        - Remove any methods from interfaces that are only used by a subset of implementing classes.

        ## 5. Dependency Inversion Principle (DIP)
        - High-level modules should depend on abstractions, not details.
        - Make all dependencies explicit, ideally through constructor parameters.
        - Use dependency injection to provide implementations.
        - Program to interfaces, not concrete classes.
        - Place abstractions in a separate package/namespace from implementations.
        - Avoid direct instantiation of service classes with 'new' in business logic.
        - Create abstraction boundaries at architectural layer transitions.
        - Define interfaces owned by the client, not the implementation.

        ## Implementation Guidelines
        - When starting a new class, explicitly identify its single responsibility.
        - Document extension points and expected subclassing behavior.
        - Write interface contracts with clear expectations and invariants.
        - Question any class that depends on many concrete implementations.
        - Use factories, dependency injection, or service locators to manage dependencies.
        - Review inheritance hierarchies to ensure LSP compliance.
        - Regularly refactor toward SOLID, especially when extending functionality.
        - Use design patterns (Strategy, Decorator, Factory, Observer, etc.) to facilitate SOLID adherence.

        ## Warning Signs
        - God classes that do "everything"
        - Methods with boolean parameters that radically change behavior
        - Deep inheritance hierarchies
        - Classes that need to know about implementation details of their dependencies
        - Circular dependencies between modules
        - High coupling between unrelated components
        - Classes that grow rapidly in size with new features
        - Methods with many parameters

  - name: General JavaScript
    rule: |
      - Assume JavaScript over TypeScript unless otherwise specified, or the working file uses a TypeScript extension.
      - Avoid classes.
      - Use functional programming best practices as much as possible.
      - Assume as few dependencies as possible, unless otherwise specified or found in the workspace's configuration files, but suggest libraries when an established and maintained one is available.
      - Use module format unless otherwise specified or detected in the project's package.json file.
      - End lines with semicolons, unless otherwise specified or found in configuration files.
      - Always adhere to eslint configuration if available.
      - Always use arrow functions, unless there's an explicit reason to use function expressions.
      - Always use parentheses in the parameter section of arrow functions, even when there is only one parameter, unless otherwise configured.
      - Favor one-line arrow function expressions for simple logic.
      - When needing functional tools that go beyond vanilla JavaScript, assume the Ramda library is available and make note of when and why you're using it.
      - Assume Vite for bundling and as the test runner.

  - name: Vue
    rule: |
      - When working with a Vue project, assume Vue3 unless otherwise specified.
      - Follow Vue3 best practices.
      - Modularize components into smaller, reusable pieces.
      - In Vue projects, always use Composition API unless otherwise specified.

  - name: React
    rule: |
      - In React projects, se functional components instead of class components.
      - In React projects, if the context includes a class component, suggest converting it to functional
      - In React projects, use hooks for state management
      - In React projects define an interface for component props
